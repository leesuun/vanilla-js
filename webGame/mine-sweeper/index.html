<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ì§€ë¢°ì°¾ê¸°</title>
        <style>
            table {
                border-collapse: collapse;
            }
            td {
                border: 1px solid #bbb;
                text-align: center;
                line-height: 25px;
                width: 25px;
                height: 25px;
                background: #888;
            }
            td.opened {
                background: white;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ì§€ë¢°ì°¾ê¸°</h1>
        </header>
        <main>
            <form>
                <input id="row" type="number" placeholder="ê°€ë¡œ(í–‰)" />
                <input id="cell" type="number" placeholder="ì„¸ë¡œ(ì—´)" />
                <input id="mine" type="number" placeholder="ì§€ë¢°" />
                <button type="submit">ì‹œì‘</button>
            </form>
            <div id="time">ê±¸ë¦° ì‹œê°„: 00:00</div>
            <table id="table">
                <tbody></tbody>
            </table>
            <div id="result"></div>
        </main>
        <script>
            const form = document.querySelector("form");

            const tbody = document.querySelector("#table tbody");
            const result = document.querySelector("#result");
            const time = document.querySelector("#time");

            let row;
            let cell;
            let mine;

            const CODE = {
                BLANK: -1,
                FLAG: -2,
                MINE: -3,
                FLAG_MINE: -4,
                OPENED: 0, // 0~8 ì§€ë¢° ê°œìˆ˜
            };
            let data = [];
            let openCellCnt = 0;
            let intervalId;

            let devMode = false;
            let firstClick = true;

            //ì§€ë¢° ê°œìˆ˜ ì„¸ê¸°
            function mineCount(rI, cI) {
                const mines = [CODE.MINE, CODE.FLAG_MINE];

                let mineCnt = 0;

                mines.includes(data[rI - 1]?.[cI - 1]) && mineCnt++;
                mines.includes(data[rI - 1]?.[cI]) && mineCnt++;
                mines.includes(data[rI - 1]?.[cI + 1]) && mineCnt++;
                mines.includes(data[rI][cI - 1]) && mineCnt++;
                mines.includes(data[rI][cI + 1]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI - 1]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI + 1]) && mineCnt++;

                return mineCnt;
            }

            //ë¹ˆì¹¸ ì—´ê¸°
            function open(rI, cI) {
                if (data[rI]?.[cI] >= CODE.OPENED) return;
                const target = tbody.children[rI]?.children[cI];
                if (!target) {
                    return;
                }

                let count = mineCount(rI, cI);
                target.textContent = count || "";
                target.className = "opened";
                data[rI][cI] = count;

                openCellCnt++; //ì—´ë¦° ì¹¸ìˆ˜
                console.log(openCellCnt);

                if (openCellCnt === cell * row - mine) {
                    console.log(openCellCnt);
                    tbody.removeEventListener("contextmenu", handleRightClick);
                    tbody.removeEventListener("click", handleLeftClick);
                    clearInterval(intervalId);
                    setTimeout(() => {
                        alert("ìŠ¹ë¦¬");
                    }, 400);
                }

                return count;
            }

            //ë¹ˆì¹¸ ì „ì´ ì‹œí‚¤ê¸°(ì¬ê·€)
            function openAround(rI, cI) {
                setTimeout(() => {
                    const count = open(rI, cI); //ì§€ë¢°ì˜ ê°œìˆ˜ ì¹´ìš´íŠ¸
                    if (count === 0) {
                        openAround(rI - 1, cI - 1);
                        openAround(rI - 1, cI);
                        openAround(rI - 1, cI + 1);
                        openAround(rI, cI - 1);
                        openAround(rI, cI + 1);
                        openAround(rI + 1, cI - 1);
                        openAround(rI + 1, cI);
                        openAround(rI + 1, cI + 1);
                    }
                }, 0);
            }

            // ì§€ë¢° ìœ„ì¹˜
            function showMines() {
                const mines = [CODE.MINE, CODE.FLAG_MINE];
                data.forEach((row, rI) => {
                    row.forEach((cell, cI) => {
                        if (mines.includes(data[rI][cI])) {
                            const target = tbody.children[rI].children[cI];
                            target.textContent = "ğŸ¥¶";
                            target.className = "opened";
                        }
                    });
                });
            }

            // ì²« í´ë¦­ ì§€ë¢° ë°©ì§€
            function switchMine(rI, cI, SrI, ScI) {
                const switchedTarget = tbody.children[SrI].children[ScI];

                const temp = data[SrI][ScI];
                data[SrI][ScI] = data[rI][cI];
                data[rI][cI] = temp;
                // switchedTarget.textContent = "ğŸ¥¶";
                return true;
            }
            // ì²« í´ë¦­ ì§€ë¢° ë°©ì§€
            function moveMine(rI, cI) {
                const target = tbody.children[rI].children[cI];
                const mines = [CODE.MINE, CODE.FLAG_MINE];
                let spaceCheck = true;

                if (mines.includes(data[rI][cI])) {
                    !mines.includes(data[rI - 1]?.[cI - 1]) &&
                        switchMine(rI, cI, rI - 1, cI - 1);
                    !mines.includes(data[rI - 1]?.[cI]) && switchMine(rI, cI, rI - 1, cI);
                    !mines.includes(data[rI - 1]?.[cI + 1]) &&
                        switchMine(rI, cI, rI - 1, cI + 1);
                    !mines.includes(data[rI]?.[cI - 1]) && switchMine(rI, cI, rI, cI - 1);
                    !mines.includes(data[rI]?.[cI + 1]) && switchMine(rI, cI, rI, cI + 1);
                    !mines.includes(data[rI + 1]?.[cI - 1]) &&
                        switchMine(rI, cI, rI + 1, cI - 1);
                    !mines.includes(data[rI + 1]?.[cI]) && switchMine(rI, cI, rI + 1, cI);
                    !mines.includes(data[rI + 1]?.[cI + 1]) &&
                        switchMine(rI, cI, rI + 1, cI + 1);
                }

                firstClick = false;
            }

            //ì¢Œí´ë¦­
            function handleLeftClick(event) {
                const target = event.target;
                const rowIdx = target.parentNode.rowIndex; // row ì¸ë±ìŠ¤
                const cellIdx = target.cellIndex; // cell ì¸ë±ìŠ¤
                let cellCode = data[rowIdx][cellIdx];

                console.log(cellCode);

                // ì²«ë²ˆì§¸ ëˆ„ë¥¸ì¹¸ì´ ì§€ë¢°ë©´ ì§€ë¢° ìœ„ì¹˜ ì´ë™
                if (firstClick) {
                    moveMine(rowIdx, cellIdx);
                    // cellCode = data[rowIdx][cellIdx];
                    // console.log(data);
                    console.log(cellCode);
                }

                if (cellCode === CODE.BLANK) {
                    // ë‹«íŒì¹¸ ,ì¹¸ ì—´ê³ 
                    openAround(rowIdx, cellIdx);
                    return;
                }
                if (cellCode === CODE.MINE) {
                    // ì§€ë¢°ì¹¸ , ì§€ë¢° ìœ„ì¹˜ ë³´ì—¬ì£¼ê³  íŒ¨ë°°
                    showMines();
                    clearInterval(intervalId);
                    tbody.removeEventListener("contextmenu", handleRightClick);
                    tbody.removeEventListener("click", handleLeftClick);
                    setTimeout(() => {
                        alert("íŒ¨ë°°");
                    }, 400);

                    return;
                }
            }

            //ìš°í´ë¦­
            function handleRightClick(event) {
                event.preventDefault();

                const target = event.target;
                const rowIdx = target.parentNode.rowIndex; // row ì¸ë±ìŠ¤
                const cellIdx = target.cellIndex; // cell ì¸ë±ìŠ¤
                const cellCode = data[rowIdx][cellIdx];

                if (cellCode === CODE.OPENED) {
                    return;
                }

                if (cellCode === CODE.BLANK) {
                    //ë¹ˆì¹¸ (ì§€ë¢° X)
                    data[rowIdx][cellIdx] = CODE.FLAG;
                    target.textContent = "ğŸš©";
                } else if (cellCode === CODE.FLAG) {
                    data[rowIdx][cellIdx] = CODE.BLANK;
                    target.textContent = "";
                    // ê¹ƒë°œ (ì§€ë¢° X)
                } else if (cellCode === CODE.MINE) {
                    //ë¹ˆì¹¸ (ì§€ë¢° O)
                    data[rowIdx][cellIdx] = CODE.FLAG_MINE;
                    target.textContent = "ğŸš©";
                } else if (cellCode === CODE.FLAG_MINE) {
                    // ê¹ƒë°œ (ì§€ë¢° O)
                    data[rowIdx][cellIdx] = CODE.MINE;
                    if (devMode) {
                        target.textContent = "ğŸ¥¶";
                    }
                }
            }

            //ì§€ë¢° ì‹¬ê¸°
            function plantMine() {
                //data ë°°ì—´ ìƒì„±
                const dataAry = Array(cell * row)
                    .fill()
                    .map((_, idx) => idx);

                // 2ì°¨ì› í…Œì´ë¸” ë°ì´í„°
                const cellAry = [];
                for (let i = 0; i < cell; i++) {
                    const rowIdx = [];
                    for (let j = 0; j < cell; j++) {
                        rowIdx.push(CODE.BLANK);
                    }
                    cellAry.push(rowIdx);
                }

                // í”¼ì…”ì—ì´ì¸  ëœë¤ ì§€ë¢° ìƒì„±
                const shuffle = [];
                while (true) {
                    const randomIdx = dataAry.splice(
                        Math.floor(Math.random() * dataAry.length),
                        1
                    )[0];
                    shuffle.push(randomIdx);
                    if (shuffle.length === mine) break;
                }

                // [120, 140, 230]
                // ì§€ë¢° ì‹¬ê¸°
                for (let i = 0; i < shuffle.length; i++) {
                    const rowIdx = Math.floor(shuffle[i] / cell);
                    const colIdx = shuffle[i] % cell;
                    cellAry[rowIdx][colIdx] = CODE.MINE;
                }

                return cellAry;
            }

            // ì§€ë¢° ë°ì´í„° ê·¸ë¦¬ê¸°
            function drawTable() {
                data = plantMine();
                data.forEach((row) => {
                    const tr = document.createElement("tr");
                    row.forEach((cell) => {
                        const td = document.createElement("td");

                        if (devMode) {
                            if (cell === CODE.MINE) {
                                td.textContent = "ğŸ¥¶";
                            }
                        }
                        tr.append(td);
                    });
                    tbody.append(tr);
                });

                tbody.addEventListener("contextmenu", handleRightClick);
                tbody.addEventListener("click", handleLeftClick);

                let i = 0;
                intervalId = setInterval(() => {
                    let startTime = new Date(1000 * i);
                    i++;
                    time.textContent = `ê±¸ë¦° ì‹œê°„: ${startTime
                        .toISOString()
                        .slice(14, 19)}`;
                }, 1000);
            }

            function handleSubmit(event) {
                event.preventDefault();
                //event.targetìœ¼ë¡œ ì°¾ì€ node valueëŠ” stringìœ¼ë¡œ ë„˜ì–´ì˜¤ë„¤
                row = parseInt(event.target.row.value);
                cell = parseInt(event.target.cell.value);
                mine = parseInt(event.target.mine.value);

                const tr = tbody.querySelectorAll("tr");
                tr.forEach((tr) => tr.remove());

                firstClick = true;
                data = [];
                openCellCnt = 0;
                clearInterval(intervalId);

                drawTable();
            }

            form.addEventListener("submit", handleSubmit);
        </script>
    </body>
</html>
