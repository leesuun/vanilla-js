<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ÏßÄÎ¢∞Ï∞æÍ∏∞</title>
        <style>
            table {
                border-collapse: collapse;
            }
            td {
                border: 1px solid #bbb;
                text-align: center;
                line-height: 25px;
                width: 25px;
                height: 25px;
                background: #888;
            }
            td.opened {
                background: white;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ÏßÄÎ¢∞Ï∞æÍ∏∞</h1>
        </header>
        <main>
            <form>
                <input id="row" type="number" placeholder="Í∞ÄÎ°ú(Ìñâ)" />
                <input id="cell" type="number" placeholder="ÏÑ∏Î°ú(Ïó¥)" />
                <input id="mine" type="number" placeholder="ÏßÄÎ¢∞" />
                <button type="submit">ÏãúÏûë</button>
            </form>
            <div id="time">Í±∏Î¶∞ ÏãúÍ∞Ñ: 00:00</div>
            <table id="table">
                <tbody></tbody>
            </table>
            <div id="result"></div>
        </main>
        <script>
            const form = document.querySelector("form");

            const tbody = document.querySelector("#table tbody");
            const result = document.querySelector("#result");
            const time = document.querySelector("#time");

            let row;
            let cell;
            let mine;

            const CODE = {
                BLANK: -1,
                FLAG: -2,
                MINE: -3,
                FLAG_MINE: -4,
                OPENED: 0, // 0~8 ÏßÄÎ¢∞ Í∞úÏàò
            };
            let data = [];
            let openCellCnt = 0;
            let intervalId;

            // let devMode = true;
            let devMode = false;
            let firstClick = true;

            //ÏßÄÎ¢∞ Í∞úÏàò ÏÑ∏Í∏∞
            function mineCount(rI, cI) {
                const mines = [CODE.MINE, CODE.FLAG_MINE];

                let mineCnt = 0;

                mines.includes(data[rI - 1]?.[cI - 1]) && mineCnt++;
                mines.includes(data[rI - 1]?.[cI]) && mineCnt++;
                mines.includes(data[rI - 1]?.[cI + 1]) && mineCnt++;
                mines.includes(data[rI][cI - 1]) && mineCnt++;
                mines.includes(data[rI][cI + 1]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI - 1]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI]) && mineCnt++;
                mines.includes(data[rI + 1]?.[cI + 1]) && mineCnt++;

                return mineCnt;
            }

            //ÎπàÏπ∏ Ïó¥Í∏∞
            function open(rI, cI) {
                if (data[rI]?.[cI] >= CODE.OPENED) return;
                const target = tbody.children[rI]?.children[cI];
                if (!target) {
                    return;
                }

                const count = mineCount(rI, cI);
                target.textContent = count || "";
                target.className = "opened";
                data[rI][cI] = count;

                openCellCnt++; //Ïó¥Î¶∞ Ïπ∏Ïàò

                if (openCellCnt === cell * row - mine) {
                    tbody.removeEventListener("contextmenu", handleRightClick);
                    tbody.removeEventListener("click", handleLeftClick);
                    clearInterval(intervalId);
                    setTimeout(() => {
                        alert("ÏäπÎ¶¨");
                    }, 400);
                }

                return count;
            }

            //ÎπàÏπ∏ Ï†ÑÏù¥ ÏãúÌÇ§Í∏∞(Ïû¨Í∑Ä)
            function openAround(rI, cI) {
                setTimeout(() => {
                    const count = open(rI, cI); //ÏßÄÎ¢∞Ïùò Í∞úÏàò Ïπ¥Ïö¥Ìä∏

                    if (count === 0) {
                        openAround(rI - 1, cI - 1);
                        openAround(rI - 1, cI);
                        openAround(rI - 1, cI + 1);
                        openAround(rI, cI - 1);
                        openAround(rI, cI + 1);
                        openAround(rI + 1, cI - 1);
                        openAround(rI + 1, cI);
                        openAround(rI + 1, cI + 1);
                    }
                }, 0);
            }

            // ÏßÄÎ¢∞ ÏúÑÏπò
            function showMines() {
                const mines = [CODE.MINE, CODE.FLAG_MINE];
                data.forEach((row, rI) => {
                    row.forEach((cell, cI) => {
                        if (mines.includes(data[rI][cI])) {
                            const target = tbody.children[rI].children[cI];
                            target.textContent = "ü•∂";
                            target.className = "opened";
                        }
                    });
                });
            }

            let spaceCheck = false;
            let searched;
            function moveMine(rI, cI) {
                if (spaceCheck) return;
                if (rI >= row || rI < 0 || cI >= cell || cI < 0) return;
                if (searched[rI][cI]) return; // Ïù¥ÎØ∏ Ï∞æÏùÄ Ïπ∏Ïù¥Î©¥ Ï¢ÖÎ£å
                const target = tbody.children[rI].children[cI];
                const mines = [CODE.MINE, CODE.FLAG_MINE];

                if (data[rI][cI] === CODE.BLANK) {
                    data[rI][cI] = CODE.MINE;
                    spaceCheck = true;
                } else {
                    searched[rI][cI] = true;
                    moveMine(rI - 1, cI - 1);
                    moveMine(rI - 1, cI);
                    moveMine(rI - 1, cI + 1);
                    moveMine(rI, cI - 1);
                    moveMine(rI, cI + 1);
                    moveMine(rI + 1, cI - 1);
                    moveMine(rI + 1, cI);
                    moveMine(rI + 1, cI + 1);
                }

                firstClick = false;
            }

            //Ï¢åÌÅ¥Î¶≠
            function handleLeftClick(event) {
                const target = event.target;
                const rowIdx = target.parentNode.rowIndex; // row Ïù∏Îç±Ïä§
                const cellIdx = target.cellIndex; // cell Ïù∏Îç±Ïä§
                let cellCode = data[rowIdx][cellIdx];

                // Ï≤´Î≤àÏß∏ ÎàÑÎ•∏Ïπ∏Ïù¥ ÏßÄÎ¢∞Î©¥ ÏßÄÎ¢∞ ÏúÑÏπò Ïù¥Îèô
                if (firstClick) {
                    searched = Array(row)
                        .fill()
                        .map(() => []);
                    if (cellCode === CODE.MINE) {
                        moveMine(rowIdx, cellIdx);
                        data[rowIdx][cellIdx] = CODE.BLANK;
                        cellCode = CODE.BLANK;
                    }
                }

                if (cellCode === CODE.BLANK) {
                    // Îã´ÌûåÏπ∏ ,Ïπ∏ Ïó¥Í≥†
                    openAround(rowIdx, cellIdx);
                    return;
                }
                if (cellCode === CODE.MINE) {
                    // ÏßÄÎ¢∞Ïπ∏ , ÏßÄÎ¢∞ ÏúÑÏπò Î≥¥Ïó¨Ï£ºÍ≥† Ìå®Î∞∞
                    showMines();
                    clearInterval(intervalId);
                    tbody.removeEventListener("contextmenu", handleRightClick);
                    tbody.removeEventListener("click", handleLeftClick);
                    setTimeout(() => {
                        alert("Ìå®Î∞∞");
                    }, 400);

                    return;
                }
            }

            //Ïö∞ÌÅ¥Î¶≠
            function handleRightClick(event) {
                event.preventDefault();

                const target = event.target;
                const rowIdx = target.parentNode.rowIndex; // row Ïù∏Îç±Ïä§
                const cellIdx = target.cellIndex; // cell Ïù∏Îç±Ïä§
                const cellCode = data[rowIdx][cellIdx];

                if (cellCode === CODE.OPENED) {
                    return;
                }

                if (cellCode === CODE.BLANK) {
                    //ÎπàÏπ∏ (ÏßÄÎ¢∞ X)
                    data[rowIdx][cellIdx] = CODE.FLAG;
                    target.textContent = "üö©";
                } else if (cellCode === CODE.FLAG) {
                    data[rowIdx][cellIdx] = CODE.BLANK;
                    target.textContent = "";
                    // ÍπÉÎ∞ú (ÏßÄÎ¢∞ X)
                } else if (cellCode === CODE.MINE) {
                    //ÎπàÏπ∏ (ÏßÄÎ¢∞ O)
                    data[rowIdx][cellIdx] = CODE.FLAG_MINE;
                    target.textContent = "üö©";
                } else if (cellCode === CODE.FLAG_MINE) {
                    // ÍπÉÎ∞ú (ÏßÄÎ¢∞ O)
                    data[rowIdx][cellIdx] = CODE.MINE;
                    if (devMode) {
                        target.textContent = "ü•∂";
                    }
                }
            }

            //ÏßÄÎ¢∞ Ïã¨Í∏∞
            function plantMine() {
                //data Î∞∞Ïó¥ ÏÉùÏÑ±
                const dataAry = Array(cell * row)
                    .fill()
                    .map((_, idx) => idx);

                // 2Ï∞®Ïõê ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞
                const cellAry = [];
                for (let i = 0; i < row; i++) {
                    const rowIdx = [];
                    for (let j = 0; j < cell; j++) {
                        rowIdx.push(CODE.BLANK);
                    }
                    cellAry.push(rowIdx);
                }

                // ÌîºÏÖîÏóêÏù¥Ï∏† ÎûúÎç§ ÏßÄÎ¢∞ ÏÉùÏÑ±
                const shuffle = [];
                while (true) {
                    const randomIdx = dataAry.splice(
                        Math.floor(Math.random() * dataAry.length),
                        1
                    )[0];
                    shuffle.push(randomIdx);
                    if (shuffle.length === mine) break;
                }

                // [120, 140, 230]
                // ÏßÄÎ¢∞ Ïã¨Í∏∞

                for (let i = 0; i < shuffle.length; i++) {
                    const rowIdx = Math.floor(shuffle[i] / cell);
                    const colIdx = shuffle[i] % cell;
                    cellAry[rowIdx][colIdx] = CODE.MINE;
                }

                return cellAry;
            }

            // ÏßÄÎ¢∞ Îç∞Ïù¥ÌÑ∞ Í∑∏Î¶¨Í∏∞
            function drawTable() {
                data = plantMine();
                data.forEach((row) => {
                    const tr = document.createElement("tr");
                    row.forEach((cell) => {
                        const td = document.createElement("td");

                        if (devMode) {
                            if (cell === CODE.MINE) {
                                td.textContent = "ü•∂";
                            }
                        }
                        tr.append(td);
                    });
                    tbody.append(tr);
                });

                tbody.addEventListener("contextmenu", handleRightClick);
                tbody.addEventListener("click", handleLeftClick);

                let i = 0;
                intervalId = setInterval(() => {
                    let startTime = new Date(1000 * i);
                    i++;
                    time.textContent = `Í±∏Î¶∞ ÏãúÍ∞Ñ: ${startTime
                        .toISOString()
                        .slice(14, 19)}`;
                }, 1000);
            }

            function handleSubmit(event) {
                event.preventDefault();
                //event.targetÏúºÎ°ú Ï∞æÏùÄ node valueÎäî stringÏúºÎ°ú ÎÑòÏñ¥Ïò§ÎÑ§
                row = parseInt(event.target.row.value);
                cell = parseInt(event.target.cell.value);
                mine = parseInt(event.target.mine.value);

                if (mine < 1) {
                    alert("ÏßÄÎ¢∞ Í∞úÏàò 1Í∞úÏù¥ÏÉÅ");
                    return;
                }
                if (row * cell < mine) {
                    alert("Ïπ∏Î≥¥Îã§ ÏßÄÎ¢∞ Í∞úÏàòÍ∞Ä Îçî ÎßéÏäµÎãàÎã§.");
                    return;
                }

                const tr = tbody.querySelectorAll("tr");
                tr.forEach((tr) => tr.remove());

                firstClick = true;
                spaceCheck = false;
                searched = null;
                data = [];
                openCellCnt = 0;
                clearInterval(intervalId);

                drawTable();
            }

            form.addEventListener("submit", handleSubmit);
        </script>
    </body>
</html>
